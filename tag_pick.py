import csv
import questionary
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
import re
from datetime import datetime
import pprint

from questionary import Style

console = Console()

custom_style = Style([
    ('selected', 'bg:#FFFFFF #000000'),  # Selected item: orange background, black text
    ('pointer', "#FFFFFF"),             # Pointer: orange
    ('highlighted', 'bg:#FFFFFF #000000'), # Highlighted item: orange background, black text
    ('text', ''),                       # Default text
    ('disabled', '#858585')              # Disabled items
])

def normalize_date(date_string: str) -> str:
    """入力された日付文字列をYYYY/MM/DD形式に正規化する。"""
    if not date_string:
        return None
    parts = date_string.split('/')
    year, month, day = int(parts[0]), int(parts[1]), int(parts[2])
    dt = datetime(year, month, day)
    return dt.strftime('%Y/%m/%d')

def is_valid_date(date_string: str):
    """YYYY/M/Dのような柔軟な日付形式を検証する。"""
    if not date_string:
        return True
    if not re.match(r"^\d{4}/\d{1,2}/\d{1,2}$", date_string):
        return "フォーマットが正しくありません。YYYY/M/D形式で入力してください。"
    try:
        parts = date_string.split('/')
        year, month, day = int(parts[0]), int(parts[1]), int(parts[2])
        datetime(year, month, day)
        return True
    except ValueError:
        return "無効な日付です。実在する日付を入力してください。"

def load_words(filename="words.csv"):
    """Loads words from a CSV file."""
    try:
        with open(filename, "r", encoding="utf-8") as f:
            reader = csv.reader(f)
            next(reader)  # Skip header
            return [row[0] for row in reader]
    except FileNotFoundError:
        console.print(f"[bold red]エラー: {filename} が見つかりません。[/bold red]")
        return None

def save_settings(settings_data, active_list_name):
    """Saves the entire settings dictionary and active list name to setting.py."""
    settings_data_str = pprint.pformat(settings_data, indent=4, width=80)

    content = f"""# settings.py

# This file is automatically generated. Do not edit manually.

settings_data = {settings_data_str}

active_list_name = {repr(active_list_name)}
"""
    with open("setting.py", "w", encoding="utf-8") as f:
        f.write(content)

def load_settings():
    """Loads settings from setting.py."""
    try:
        from setting import settings_data, active_list_name
        # Ensure series_list exists for all loaded settings
        for list_name, settings in settings_data.items():
            if 'series_list' not in settings:
                settings['series_list'] = []
        return settings_data, active_list_name
    except (ImportError, AttributeError, SyntaxError):
        return {}, None

def print_help():
    """Prints the help message."""
    help_text = (
        "リスト名に紐づけて、プラント名、期間、単語リストを管理します。\n\n"
        "[bold]主な操作:[/bold]\n"
        "- [bold]リスト名を変更/選択する[/bold]:\n"
        "  - 既存のリストを選択するか、新しいリストを作成します。\n"
        "  - すべての設定はリスト名に紐づいて保存・読み込みされます。\n"
        "- [bold]リストを削除する[/bold]:\n"
        "  - 既存のリストを削除します。この操作は元に戻せません。\n"
        "- [bold]単語を検索してピックアップする[/bold]:\n"
        "  - 現在選択中のリストに単語を追加します。\n"
        "- [bold]ピックアップリストから削除する[/bold]:\n"
        "  - ピックアップ済みの単語をリストから削除します。\n"
        "- [bold]その他の設定[/bold]:\n"
        "  - プラント名や期間は、現在選択中のリストに対して設定されます。"
    )
    console.print(Panel(help_text, title="[bold cyan]ヘルプ[/bold cyan]", border_style="cyan"))


def parse_and_validate_pasted_series(pasted_text):
    """Parses and validates pasted multiline text using regex to handle concatenated data."""
    lines = pasted_text.strip().split('\n')
    parsed_series = []
    errors = []

    # Regex to capture (Series Name)(Start Date)(End Date) from a concatenated string
    # e.g., "SCS-52022/1/12024/1/1"
    series_pattern = re.compile(r"^(.*?)(\d{4}/\d{1,2}/\d{1,2})(\d{4}/\d{1,2}/\d{1,2})$")

    for i, line in enumerate(lines):
        if not line.strip():
            continue  # Skip empty lines

        match = series_pattern.match(line.strip())

        if not match:
            errors.append(f"行 {i+1}: 形式が不正です。'シリーズ名YYYY/M/DYYYY/M/D' のように連結された形式で入力してください。")
            continue

        series_name, start_str, end_str = match.groups()

        try:
            start_date = datetime.strptime(start_str, '%Y/%m/%d')
        except ValueError:
            # This should not happen if regex matches, but as a safeguard
            errors.append(f"行 {i+1}: 開始日 '{start_str}' が無効な日付です。")
            start_date = None

        try:
            end_date = datetime.strptime(end_str, '%Y/%m/%d')
        except ValueError:
            # This should not happen if regex matches, but as a safeguard
            errors.append(f"行 {i+1}: 終了日 '{end_str}' が無効な日付です。")
            end_date = None

        if start_date and end_date and start_date > end_date:
            errors.append(f"行 {i+1}: 終了日 ({end_str}) が開始日 ({start_str}) より前です。")

        # Add to list only if no new errors were found for this line
        if not errors or len(errors) == len(parsed_series):
            parsed_series.append({
                "series_name": series_name.strip(),
                "start_date": start_date.strftime('%Y/%m/%d'),
                "end_date": end_date.strftime('%Y/%m/%d')
            })

    # If any errors were found at all, return an empty list and the errors
    if errors:
        return [], errors
    
    return parsed_series, []


def manage_series_list(current_series_list):
    """Manages the series list for the active list."""
    while True:
        choices = [
            "シリーズを一覧表示する",
            "シリーズを1件ずつ追加する",
            "スプレッドシートから貼り付けて追加する",
            "シリーズを削除する",
            "戻る"
        ]
        action = questionary.select("シリーズリストの操作を選択してください:", choices=choices, style=custom_style).ask()

        if action == "戻る" or action is None:
            break

        elif action == "シリーズを一覧表示する":
            if not current_series_list:
                console.print("[yellow]シリーズリストは空です。[/yellow]")
            else:
                table = Table(title="[bold]シリーズリスト[/bold]")
                table.add_column("No.", style="dim")
                table.add_column("シリーズ名")
                table.add_column("開始日")
                table.add_column("終了日")

                for i, series in enumerate(current_series_list):
                    table.add_row(str(i+1), series['series_name'], series['start_date'], series['end_date'])
                
                console.print(table)

        elif action == "シリーズを1件ずつ追加する":
            series_name = questionary.text("新しいシリーズ名を入力してください:", style=custom_style).ask()

            if not series_name:
                continue

            start_date = questionary.text("開始日 (YYYY/M/D):", validate=is_valid_date, style=custom_style).ask()
            if not start_date:
                continue

            def validate_end_date(date_string):
                if not date_string: return True
                res = is_valid_date(date_string)
                if res is not True: return res
                if normalize_date(date_string) < normalize_date(start_date):
                    return f"終了日は開始日 ({normalize_date(start_date)}) 以降にしてください。"
                return True

            end_date = questionary.text("終了日 (YYYY/M/D):", validate=validate_end_date, style=custom_style).ask()
            if not end_date:
                continue

            current_series_list.append({
                "series_name": series_name,
                "start_date": normalize_date(start_date),
                "end_date": normalize_date(end_date)
            })
            current_series_list.sort(key=lambda x: x['series_name'])
            console.print("[bold green]シリーズを追加しました。[/bold green]")

        elif action == "スプレッドシートから貼り付けて追加する":
            console.print(
                "スプレッドシートから「シリーズ名」「開始日」「終了日」の3列をコピーし、"
                "ここに貼り付けてください。（Ctrl+D または Esc, Enterで入力を完了）",
                style="bold cyan"
            )
            pasted_text = questionary.text(
                "貼り付け:",
                multiline=True,
                style=custom_style
            ).ask()

            if pasted_text:
                new_series, errors = parse_and_validate_pasted_series(pasted_text)
                if errors:
                    console.print("[bold red]入力内容にエラーが見つかりました:[/bold red]")
                    for error in errors:
                        console.print(f"- {error}")
                elif new_series:
                    # Preview the parsed data in a table
                    table = Table(title="[bold]プレビュー[/bold]")
                    table.add_column("シリーズ名")
                    table.add_column("開始日")
                    table.add_column("終了日")

                    for s in new_series:
                        table.add_row(s['series_name'], s['start_date'], s['end_date'])
                    
                    console.print(table)

                    confirmed = questionary.confirm("この内容で登録しますか？", default=True, style=custom_style).ask()
                    if confirmed:
                        current_series_list.extend(new_series)
                        current_series_list.sort(key=lambda x: x['series_name'])
                        console.print(f"[bold green]{len(new_series)}件のシリーズを追加しました。[/bold green]")
                    else:
                        console.print("[yellow]登録をキャンセルしました。[/yellow]")

        elif action == "シリーズを削除する":
            if not current_series_list:
                console.print("[yellow]削除できるシリーズがありません。[/yellow]")
                continue

            choices = [f"{s['series_name']} ({s['start_date']} - {s['end_date']})" for s in current_series_list]
            series_to_delete = questionary.checkbox("削除するシリーズを選択:", choices=choices, style=custom_style).ask()

            if series_to_delete:
                current_series_list[:] = [s for s in current_series_list if f"{s['series_name']} ({s['start_date']} - {s['end_date']})" not in series_to_delete]
                console.print("[bold red]選択されたシリーズを削除しました。[/bold red]")


def manage_picked_words(all_words, active_list_name, settings_data, custom_style, console):
    """Manages adding and removing words from the picked list."""
    while True:
        # Get current picked words from settings_data for the active list
        current_picked_words = settings_data.get(active_list_name, {}).get('picked_words', [])

        available_words = [w for w in all_words if w not in current_picked_words]
        choices = [
            questionary.Choice("単語を検索してピックアップする", disabled=not available_words),
            questionary.Choice("ピックアップリストから削除する", disabled=not current_picked_words),
            "戻る"
        ]
        action = questionary.select("単語の設定:", choices=choices, style=custom_style).ask()

        if action == "戻る" or action is None:
            break

        elif action == "単語を検索してピックアップする":
            search_term = questionary.autocomplete(
                "検索語を入力してください:",
                choices=available_words,
                validate=lambda text: True if text else "検索語を入力してください。",
                style=custom_style
            ).ask()

            if not search_term:
                continue

            search_results = sorted([w for w in available_words if search_term.lower() in w.lower()])

            if not search_results:
                console.print("[yellow]一致する単語は見つかりませんでした。[/yellow]")
                continue

            words_to_add = questionary.checkbox(
                "ピックアップする単語をスペースキーで選択してください（Enterで確定）:",
                choices=search_results,
                style=custom_style
            ).ask()

            if words_to_add:
                current_picked_words.extend(words_to_add)
                settings_data[active_list_name]['picked_words'] = sorted(list(set(current_picked_words)))
                console.print(f"[bold green]✓ {len(words_to_add)}件の単語をピックアップしました。[/bold green]")

        elif action == "ピックアップリストから削除する":
            words_to_remove = questionary.checkbox("削除する単語を選択:", choices=current_picked_words, style=custom_style).ask()
            if words_to_remove:
                settings_data[active_list_name]['picked_words'] = sorted([w for w in current_picked_words if w not in words_to_remove])
                console.print("[bold green]選択された単語をピックアップリストから削除しました。[/bold green]")

def manage_picked_words(all_words, active_list_name, settings_data, custom_style, console):
    """Manages adding and removing words from the picked list."""
    while True:
        # Get current picked words from settings_data for the active list
        current_picked_words = settings_data.get(active_list_name, {}).get('picked_words', [])

        available_words = [w for w in all_words if w not in current_picked_words]
        choices = [
            questionary.Choice("単語を検索してピックアップする", disabled=not available_words),
            questionary.Choice("ピックアップリストから削除する", disabled=not current_picked_words),
            "戻る"
        ]
        action = questionary.select("単語の設定:", choices=choices, style=custom_style).ask()

        if action == "戻る" or action is None:
            break

        elif action == "単語を検索してピックアップする":
            search_term = questionary.autocomplete(
                "検索語を入力してください:",
                choices=available_words,
                validate=lambda text: True if text else "検索語を入力してください。",
                style=custom_style
            ).ask()

            if not search_term:
                continue

            search_results = sorted([w for w in available_words if search_term.lower() in w.lower()])

            if not search_results:
                console.print("[yellow]一致する単語は見つかりませんでした。[/yellow]")
                continue

            words_to_add = questionary.checkbox(
                "ピックアップする単語をスペースキーで選択してください（Enterで確定）:",
                choices=search_results,
                style=custom_style
            ).ask()

            if words_to_add:
                current_picked_words.extend(words_to_add)
                settings_data[active_list_name]['picked_words'] = sorted(list(set(current_picked_words)))
                console.print(f"[bold green]✓ {len(words_to_add)}件の単語をピックアップしました。[/bold green]")

        elif action == "ピックアップリストから削除する":
            words_to_remove = questionary.checkbox("削除する単語を選択:", choices=current_picked_words, style=custom_style).ask()
            if words_to_remove:
                settings_data[active_list_name]['picked_words'] = sorted([w for w in current_picked_words if w not in words_to_remove])
                console.print("[bold green]選択された単語をピックアップリストから削除しました。[/bold green]")

def main():
    """Main function for the interactive CLI app."""
    all_words = load_words()
    if all_words is None:
        return

    settings_data, active_list_name = load_settings()

    console.print(Panel("[bold]単語ピックアップツールへようこそ！[/bold]", style="bold blue"))

    while True:
        # Get current settings based on active list name
        current_settings = settings_data.get(active_list_name, {})
        list_name = active_list_name
        plant_name = current_settings.get('plant_name')
        start_date = current_settings.get('start_date')
        end_date = current_settings.get('end_date')
        picked_words = current_settings.get('picked_words', [])

        # Save settings on every loop to ensure persistence
        save_settings(settings_data, active_list_name)

        # Display current status
        title = "\n[bold green]現在のリスト: "
        if list_name:
            title += f"[bold yellow]{list_name}[/bold yellow]"
            details = []
            if plant_name: details.append(f"プラント: {plant_name}")
            if start_date: details.append(f"開始日: {start_date}")
            if end_date: details.append(f"終了日: {end_date}")
            if details:
                title += f" ({', '.join(details)})"
        else:
            title += "[bold red](未選択)[/bold red]"
        console.print(title)

        if picked_words:
            console.print(", ".join(picked_words))
        else:
            console.print("[dim]（空）[/dim]")

        # Define choices, disabling some if no list is active
        choices = [
            "リスト名を変更/選択する",
            questionary.Choice("プラント名を設定する", disabled=not active_list_name),
            questionary.Choice("期間を設定する", disabled=not active_list_name),
            questionary.Choice("単語を設定する", disabled=not active_list_name),
            questionary.Choice("シリーズリストを設定する", disabled=not active_list_name),
            questionary.Choice("リストを削除する", disabled=not settings_data),
            "ヘルプを表示する",
            "終了する",
        ]

        action = questionary.select("何をしますか？", choices=choices, style=custom_style).ask()

        if action is None or action == "終了する":
            console.print("[bold blue]アプリケーションを終了します。[/bold blue]")
            break

        elif action == "シリーズリストを設定する":
            # Pass the series_list associated with the active_list_name
            manage_series_list(current_settings.setdefault('series_list', []))

        elif action == "リスト名を変更/選択する":
            existing_lists = list(settings_data.keys())
            choices = sorted(existing_lists) + ["[ 新しいリストを作成 ]"]
            
            selected_option = questionary.select(
                "どのリストを扱いますか？", choices=choices, style=custom_style
            ).ask()

            if selected_option == "[ 新しいリストを作成 ]":
                new_name = questionary.text("新しいリスト名を入力してください:", style=custom_style).ask()
                if new_name and new_name not in settings_data:
                    active_list_name = new_name
                    settings_data[active_list_name] = {'picked_words': []} # Initialize
                    console.print(f"[bold blue]新しいリスト「{active_list_name}」を作成しました。[/bold blue]")
                elif not new_name:
                    console.print("[yellow]リスト名は空にできません。[/yellow]")
                else:
                    console.print(f"[yellow]リスト「{new_name}」は既に存在します。[/yellow]")
            elif selected_option:
                active_list_name = selected_option
                console.print(f"[bold blue]リスト「{active_list_name}」を選択しました。[/bold blue]")

        elif action == "プラント名を設定する":
            new_plant_name = questionary.text("プラント名を入力してください:", default=plant_name or "", style=custom_style).ask()
            settings_data[active_list_name]['plant_name'] = new_plant_name

        elif action == "期間を設定する":
            start_input = questionary.text("開始日 (YYYY/M/D):", validate=is_valid_date, default=start_date or "", style=custom_style).ask()
            settings_data[active_list_name]['start_date'] = normalize_date(start_input)

            def validate_end_date(date_string):
                current_start = settings_data[active_list_name].get('start_date')
                if not date_string: return True
                res = is_valid_date(date_string)
                if res is not True: return res
                if current_start and normalize_date(date_string) < current_start:
                    return f"終了日は開始日 ({current_start}) 以降にしてください。"
                return True

            end_input = questionary.text("終了日 (YYYY/M/D):", validate=validate_end_date, default=end_date or "", style=custom_style).ask()
            settings_data[active_list_name]['end_date'] = normalize_date(end_input)

        elif action == "単語を設定する":
            manage_picked_words(all_words, active_list_name, settings_data, custom_style, console)

        elif action == "リストを削除する":
            if not settings_data:
                console.print("[yellow]削除できるリストがありません。[/yellow]")
                continue

            lists_to_delete = questionary.checkbox(
                "削除するリストを選択してください（スペースキーで選択、Enterで確定）:",
                choices=sorted(list(settings_data.keys())),
                style=custom_style
            ).ask()

            if lists_to_delete:
                confirmed = questionary.confirm(
                    f"本当にリスト {', '.join(lists_to_delete)} を削除しますか？この操作は元に戻せません。",
                    default=False,
                    style=custom_style
                ).ask()

                if confirmed:
                    for list_name_to_delete in lists_to_delete:
                        if list_name_to_delete in settings_data:
                            del settings_data[list_name_to_delete]
                        if active_list_name == list_name_to_delete:
                            active_list_name = None
                    console.print(f"[bold red]リスト {', '.join(lists_to_delete)} を削除しました。[/bold red]")

        elif action == "ヘルプを表示する":
            print_help()

if __name__ == "__main__":
    main()
